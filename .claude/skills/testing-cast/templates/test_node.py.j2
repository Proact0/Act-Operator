"""Tests for {{ node_name }}."""

import pytest
from casts.{{ cast_name }}.nodes import {{ node_name }}
from casts.{{ cast_name }}.state import {{ state_class }}


class Test{{ node_name }}:
    """Tests for {{ node_name }}."""

    @pytest.fixture
    def node(self{% if has_llm %}, mock_llm{% endif %}):
        """Provide {{ node_name }} instance."""
        return {{ node_name }}({% if has_llm %}model=mock_llm{% endif %})

    @pytest.fixture
    def sample_state(self):
        """Provide sample state for testing."""
        return {
            "messages": [],
            "task": "test task",
            # Add other required state fields
        }

    def test_execute_basic(self, node, sample_state):
        """Test basic execution."""
        result = node.execute(sample_state)

        assert isinstance(result, dict)
        assert "messages" in result or "result" in result

    def test_execute_with_valid_input(self, node, sample_state):
        """Test execution with valid input."""
        sample_state["task"] = "valid test task"

        result = node.execute(sample_state)

        assert result is not None
        # Add specific assertions

    def test_execute_handles_errors(self, node):
        """Test error handling."""
        invalid_state = {}  # Invalid state

        result = node.execute(invalid_state)

        # Should handle gracefully
        assert "error" in result or result is not None

    @pytest.mark.parametrize("input_data,expected", [
        ("test1", "expected1"),
        ("test2", "expected2"),
    ])
    def test_execute_parametrized(self, node, sample_state, input_data, expected):
        """Test with multiple inputs."""
        sample_state["data"] = input_data
        result = node.execute(sample_state)
        # Add assertions based on expected

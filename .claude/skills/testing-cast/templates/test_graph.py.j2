"""Tests for {{ graph_name }}."""

import pytest
from langgraph.checkpoint.memory import MemorySaver
from casts.{{ cast_name }}.graph import {{ graph_name }}


class Test{{ graph_name }}:
    """Integration tests for {{ graph_name }}."""

    @pytest.fixture
    def graph(self{% if has_llm %}, mock_llm{% endif %}):
        """Provide test graph."""
        return {{ graph_name }}(
            {% if has_llm %}model=mock_llm,{% endif %}
            checkpointer=MemorySaver()
        ).build()

    @pytest.fixture
    def test_config(self):
        """Provide test config with thread_id."""
        return {"configurable": {"thread_id": "test-123"}}

    def test_graph_execution_basic(self, graph):
        """Test basic graph execution."""
        result = graph.invoke({
            "messages": [],
            "task": "test task"
        })

        assert result is not None
        assert "status" in result or "messages" in result

    def test_graph_with_config(self, graph, test_config):
        """Test graph execution with config."""
        result = graph.invoke(
            {"messages": [], "task": "test"},
            test_config
        )

        assert result is not None

        # Verify state was saved
        state = graph.get_state(test_config)
        assert state.values is not None

    def test_graph_state_flow(self, graph, test_config):
        """Test state flow through graph."""
        # First invocation
        result1 = graph.invoke(
            {"messages": [], "count": 1},
            test_config
        )

        # Second invocation - test accumulation
        result2 = graph.invoke(
            {"count": 1},
            test_config
        )

        # Verify accumulation or state progression

    @pytest.mark.slow
    def test_graph_complete_workflow(self, graph):
        """Test complete multi-step workflow."""
        result = graph.invoke({
            "messages": [],
            "task": "complex task"
        })

        assert result["status"] == "completed"
